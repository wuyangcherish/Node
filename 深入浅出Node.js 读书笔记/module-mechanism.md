## 模块机制
	
####  CommonJS 模块规范

1. 模块定义： 例如： math.js

<pre>
	exports.add = function(){
		var total = 0;
		var args = arguments;
		//...
	}
</pre>

2. 模块引用： var math = require("math");

3. 模块标识: 其实就是传递给 require() 函数的参数，必须是小驼峰命名的字符串，或者以../ or . 开头的相对路径，或者绝对路径.可以没有后缀名.js

#### Node 的模块实现

1. 在 Node 中引入模块需要经历三个步骤

	1. 路径分析
	2. 文件定位
	3. 编译执行
	
2. 模块的分类：

	1. 核心模块：由Node 提供的模块。
		* 该模块部分在Node 源代码中的编译过程中，编译了二进制的文件，在Node 进程启动的时候，部分的核心模块就直接被加载在内存中，所以这部分模块引入的时候，文件定位和编译执行都不需要，加载速度最快
		
	2. 文件模块： 用户编写的模块
	
		* 运行时动态加载。需要完整的三步骤。速度比核心模块慢
		
	3. 不管是哪种模块，第二次加载的时候都是优先从内存中加载。这是第一优先级。
	
3. 路径分析 && 文件定位

	1. 模块标识符分析：
		1. 核心模块加载速度仅次于缓存加载
		2. 以 . , ../ 和 / 开始的被当做文件模块处理，分析路径的时候会将路径转化为真实路径，编译执行并放入缓存中
		3. 自定义模块：非核心模块但也不是以路径形式开头的，
			* 模块路径：Node在定位文件模块时制定的查找策略， 具体表现为一个路径组成的数组
				
			* 查找顺序： 当前文件目录下的 node_module 目录，--> 父目录下的node_module 目录 --> 父目录的父目录下的 node_module 目录 -------> 一直递归找 直到 根目录下得 node_module 目录
			
		4. 看的出来这个自定义模块式加载速度最慢的
		
	2. 文件定位：
		1. 文件第二次加载优先从缓存中加载，无需经过三步骤
		2. 没有文件扩展名的情况下Node 按照：.js .json .node  的次序补足
		
#### 模块编译：

1. .js： 通过 fs 模块同步读取文件后进行编译执行
2. .json: 通过fs 模块同步读取文件后用JSON.parse() 解析返回结果
3. .node: C/C++ 编写的扩展文件。 通过 dlopen() 方法加载最后编译生成文件
4. 其他扩展名文件都会被当做.js 文件载入

###### JavaScript模块的编译：

* 在编译的过程中, Node 会对获取到的JavaScript 进行一次包装 ，例如：
<pre>
	(function(exports, require, module, _filename, _dirname){
		var math = require('math');
		//...
	})
</pre>
	
这样每个模块文件之间都进行了作用于的隔离，包装之后的代码会通过 runInThisContext()方法执行，返回一个具体的function 对象。所以在咱们自己写的函数里面可以直接使用require() 等这些属性

* exports && module.exports :
	* exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但不能改变作用域外的值。如果要达到require() 引入一个类的效果，用 module.exports对象。
		
###### C/C++ 模块的编译

* Node 调用process.dlopen()方法进行加载和执行的.Libuv对 该方法进行了平台的兼容性处理。
* .node 模块文件不需要编译。因为他是编写 C/C++ 模块之后编译生成的，在执行的过程中，模块的exports对象与 .node 模块产生联系，然后返回给调用者。		


	
	

	



































